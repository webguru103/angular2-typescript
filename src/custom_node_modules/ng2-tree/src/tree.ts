import * as _ from 'lodash';
import { Observer } from 'rxjs/Observer';
import { Observable } from 'rxjs/Observable';
import { TreeModel, FoldingType, ChildrenLoadingFunction } from './tree.types';

enum ChildrenLoadingState {
  NotStarted,
  Loading,
  Completed
}

export class Tree {
  private _children: Tree[];
  private _loadChildren: ChildrenLoadingFunction;
  private _childrenLoadingState: ChildrenLoadingState = ChildrenLoadingState.NotStarted;
  public node: TreeModel;
  public parent: Tree;

  /**
   * Build an instance of Tree from an object implementing TreeModel interface.
   * @param {TreeModel} model - A model that is used to build a tree.
   * @param {Tree} [parent] - An optional parent if you want to build a tree from the model that should be a child of an existing Tree instance.
   * @param {boolean} [isBranch] - An option that makes a branch from created tree. Branch can have children.
   */
  public constructor(node: TreeModel, parent: Tree = null, isBranch = false) {
    this.buildTreeFromModel(node, parent, isBranch);
  }

  private buildTreeFromModel(model: TreeModel, parent: Tree, isBranch: boolean): void {
    this.parent = parent;
    this.node = _.extend(_.omit(model, 'children') as TreeModel) as TreeModel;

    if (_.isFunction(this.node.loadChildren)) {
      this._loadChildren = this.node.loadChildren;
    } else {
      _.forEach(_.get(model, 'children') as TreeModel[], (child: TreeModel, index: number) => {
        if (child.children.length) {
          child.foldingType = FoldingType.Collapsed;
        }
        this._addChild(new Tree(child, this), index);
      });
    }

    if (!Array.isArray(this._children)) {
      this._children = this.node.loadChildren || isBranch ? [] : null;
    }
  }

  /**
   * Check whether children of the node are being loaded.
   * Makes sense only for nodes that define `loadChildren` function.
   * @returns {boolean} A flag indicating that children are being loaded.
   */
  public childrenAreBeingLoaded(): boolean {
    return (this._childrenLoadingState === ChildrenLoadingState.Loading);
  }

  private canLoadChildren(): boolean {
    return (this._childrenLoadingState === ChildrenLoadingState.NotStarted)
      && (this.foldingType === FoldingType.Expanded)
      && (!!this._loadChildren);
  }

  /**
   * Check whether children of the node should be loaded and not loaded yet.
   * Makes sense only for nodes that define `loadChildren` function.
   * @returns {boolean} A flag indicating that children should be loaded for the current node.
   */
  public childrenShouldBeLoaded(): boolean {
    return !!this._loadChildren;
  }

  /**
   * Get children of the current tree.
   * @returns {Tree[]} The children of the current tree.
   */
  public get children(): Tree[] {
    return this._children;
  }

  /**
   * By getting value from this property you start process of loading node's children using `loadChildren` function.
   * Once children are loaded `loadChildren` function won't be called anymore
   * and loaded for the first time children are emitted in case of subsequent calls.
   * @returns {Observable<Tree[]>} An observable which emits children once they are loaded.
   */
  public get childrenAsync(): Observable<Tree[]> {
    if (this.canLoadChildren()) {
      setTimeout(() => this._childrenLoadingState = ChildrenLoadingState.Loading);
      return new Observable((observer: Observer<Tree[]>) => {
        this._loadChildren((children: TreeModel[]) => {
          this._children = _.map(children, (child: TreeModel) => new Tree(child, this));
          this._childrenLoadingState = ChildrenLoadingState.Completed;
          observer.next(this.children);
          observer.complete();
        });
      });
    }

    return Observable.of(this.children);
  }

  /**
   * Get the value of the current node
   * @returns {(string)} The value of the node.
   */
  public get value(): string {
    return this.node.value;
  }

  /**
   * Set the value of the current node
   * @param {(string)} value - The new value of the node.
   */
  public set value(value: string) {
    if (typeof value !== 'string') {
      return;
    }

    this.node.value = Tree.isValueEmpty(value as string) ? this.node.value : _.toString(value);
  }

  private _addChild(child: Tree, position: number = _.size(this._children) || 0): Tree {
    child.parent = this;

    if (Array.isArray(this._children)) {
      this._children.splice(position, 0, child);
    } else {
      this._children = [child];
    }
    return child;
  }

  /**
   * Get a node's position in its parent.
   * @returns {number} The position inside a parent.
   */
  public get positionInParent(): number {
    return _.indexOf(this.parent.children, this);
  }

  /**
   * Check whether this tree is "Leaf" or not.
   * @returns {boolean} A flag indicating whether or not this tree is a "Leaf".
   */
  public isLeaf(): boolean {
    return !this.isBranch();
  }

  /**
   * Check whether this tree is "Branch" or not. "Branch" is a node that has children.
   * @returns {boolean} A flag indicating whether or not this tree is a "Branch".
   */
  public isBranch(): boolean {
    return Array.isArray(this._children);
  }

  /**
   * Check whether this tree is a root or not. The root is the tree (node) that doesn't have parent (or technically its parent is null).
   * @returns {boolean} A flag indicating whether or not this tree is the root.
   */
  public isRoot(): boolean {
    return this.parent === null;
  }

  /**
   * Check whether provided tree is a sibling of the current tree. Sibling trees (nodes) are the trees that have the same parent.
   * @param {Tree} tree - A tree that should be tested on a siblingness.
   * @returns {boolean} A flag indicating whether or not provided tree is the sibling of the current one.
   */
  public hasSibling(tree: Tree): boolean {
    return !this.isRoot() && _.includes(this.parent.children, tree);
  }

  /**
   * Check whether provided tree is a child of the current tree.
   * This method tests that provided tree is a <strong>direct</strong> child of the current tree.
   * @param {Tree} tree - A tree that should be tested (child candidate).
   * @returns {boolean} A flag indicating whether provided tree is a child or not.
   */
  public hasChild(tree: Tree): boolean {
    return _.includes(this._children, tree);
  }

  public switchFoldingType(): void {
    this.node.foldingType = this.isNodeExpanded() ? FoldingType.Collapsed : FoldingType.Expanded;
  }

  /**
   * Check that tree is expanded.
   * @returns {boolean} A flag indicating whether current tree is expanded. Always returns false for the "Leaf" tree.
   */
  public isNodeExpanded(): boolean {
    const result = this.foldingType === FoldingType.Expanded;
    return result;
  }

  /**
   * Get a current folding type: expanded, collapsed or leaf.
   * @returns {FoldingType} A folding type of the current tree.
   */
  public get foldingType(): FoldingType {
    if (!this.node.foldingType) {
      if (this.childrenShouldBeLoaded()) {
        this.node.foldingType = FoldingType.Collapsed;
      } else if (this._children) {
        this.node.foldingType = FoldingType.Expanded;
      } else {
        this.node.foldingType = FoldingType.Leaf;
      }
    }
    return this.node.foldingType;
  }

  // STATIC METHODS ----------------------------------------------------------------------------------------------------

  /**
   * Check that value passed is not empty (it doesn't consist of only whitespace symbols).
   * @param {string} value - A value that should be checked.
   * @returns {boolean} - A flag indicating that value is empty or not.
   * @static
   */
  public static isValueEmpty(value: string): boolean {
    return _.isEmpty(_.trim(value));
  }

  private static cloneTreeShallow(origin: Tree): Tree {
    const tree = new Tree(_.clone(origin.node));
    tree._children = origin._children;
    return tree;
  };
}
